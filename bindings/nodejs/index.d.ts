/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class ZenDecision {
  constructor()
  evaluate(context: any, opts?: ZenEvaluateOptions | undefined | null): Promise<ZenEngineResponse>
  safeEvaluate(context: any, opts?: ZenEvaluateOptions | undefined | null): Promise<SafeResult<ZenEngineResponse>>
  validate(): void
}

export declare class ZenDecisionContent {
  constructor(content: Buffer | object)
  toBuffer(): Buffer
}

export declare class ZenEngine {
  constructor(options?: ZenEngineOptions | undefined | null)
  evaluate(key: string, context: any, opts?: ZenEvaluateOptions | undefined | null): Promise<ZenEngineResponse>
  createDecision(content: ZenDecisionContent | Buffer | object): ZenDecision
  getDecision(key: string): Promise<ZenDecision>
  safeEvaluate(key: string, context: any, opts?: ZenEvaluateOptions | undefined | null): Promise<SafeResult<ZenEngineResponse>>
  safeGetDecision(key: string): Promise<SafeResult<ZenDecision>>
}

export declare class ZenEngineHandlerRequest {
  constructor()
  getField(path: string): unknown
  getFieldRaw(path: string): unknown
}

export interface DecisionNode {
  id: string
  name: string
  kind: string
  config: any
}

export declare function evaluateExpression(expression: string, context?: any | undefined | null): Promise<any>

export declare function evaluateExpressionSync(expression: string, context?: any | undefined | null): any

export declare function evaluateUnaryExpression(expression: string, context: any): Promise<boolean>

export declare function evaluateUnaryExpressionSync(expression: string, context: any): boolean

export declare function overrideConfig(config: ZenConfig): void

export declare function renderTemplate(template: string, context: any): Promise<any>

export declare function renderTemplateSync(template: string, context: any): any

export interface ZenConfig {
  nodesInContext?: boolean
  functionTimeoutMillis?: number
}

export interface ZenEngineHandlerResponse {
  output: any
  traceData?: any
}

export interface ZenEngineOptions {
  loader?: (key: string) => Promise<Buffer | ZenDecisionContent>
  customHandler?: (request: ZenEngineHandlerRequest) => Promise<ZenEngineHandlerResponse>
}

export interface ZenEngineResponse {
  performance: string
  result: any
  trace?: Record<string, ZenEngineTrace>
}

export interface ZenEngineTrace {
  id: string
  name: string
  input: any
  output: any
  performance?: string
  traceData?: any
  order: number
}

export interface ZenEvaluateOptions {
  maxDepth?: number
  trace?: boolean | 'string' | 'reference' | 'referenceString'
}
